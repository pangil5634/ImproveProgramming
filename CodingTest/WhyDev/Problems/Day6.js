//  문제 내용
/*
    동혁이는 나무 조각을 5개 가지고 있다. 나무 조각에는 1부터 5까지 숫자 중 하나가 쓰여져 있다. 또, 모든 숫자는 다섯 조각 중 하나에만 쓰여 있다.
    
    동혁이는 나무 조각을 다음과 같은 과정을 거쳐서 1, 2, 3, 4, 5 순서로 만들려고 한다.

    첫 번째 조각의 수가 두 번째 수보다 크다면, 둘의 위치를 서로 바꾼다.
    두 번째 조각의 수가 세 번째 수보다 크다면, 둘의 위치를 서로 바꾼다.
    세 번째 조각의 수가 네 번째 수보다 크다면, 둘의 위치를 서로 바꾼다.
    네 번째 조각의 수가 다섯 번째 수보다 크다면, 둘의 위치를 서로 바꾼다.
    만약 순서가 1, 2, 3, 4, 5 순서가 아니라면 1 단계로 다시 간다.
    
    처음 조각의 순서가 주어졌을 때, 위치를 바꿀 때 마다 조각의 순서를 출력하는 프로그램을 작성하시오.
*/

//  문제 분석
/*
    - 한 행에 다섯 개의 숫자가 입력된다.
    - 위치가 바뀔 때마다 현재 순서를 출력한다.
    - 
*/

//  문제 조건

/*
    입력
    - 첫째 줄에 조각에 쓰여 있는 수가 순서대로 주어진다. 
    - 숫자는 1보다 크거나 같고, 5보다 작거나 같으며, 중복되지 않는다. 처음 순서는 1, 2, 3, 4, 5가 아니다.
    
    출력
    - 두 조각의 순서가 바뀔때 마다 조각의 순서를 출력한다.
*/

//  예제 입력 및 출력
/*
    입력1
    2 1 5 3 4

    출력1
    1 2 5 3 4
    1 2 3 5 4
    1 2 3 4 5

    입력2
    2 3 4 5 1

    출력2
    2 3 4 1 5
    2 3 1 4 5
    2 1 3 4 5
    1 2 3 4 5
*/

// 문제 풀이
/*
    - 목표 : 오름차순으로 정렬하는 과정을 출력한다.
    
    - 종료 조건 : 더이상 위치를 바꿀 수 없는 경우.
    - flag를 설정해서 swap이 일어나지 않아 flag가 그대로이면 종료.

    - swap하는 함수를 만들어서 사용하면 더 좋겠다.

*/


// 기준대로 배열을 정렬하고, swap 발생시 출력하는 함수
function getSwapAndSort(input) {

    let flag = 0; // 종료 조건을 위한 변수

    // 탐색 후 종료 조건을 확인하는 것을 위해 do~while문 사용
    do {
        flag = 0; // 한 번 탐색을 위해서는 flag를 0으로 초기화

        // 배열 길이 만큼 탐색하면서 swap 조건 발견하면 swap 진행 후 출력
        for (let i = 0; i < input.length-1; i++){
            if (input[i] > input[i + 1]) {
                [input[i], input[i+1]] = swap(input[i], input[i + 1]); // swap
                console.log(input.join(" ")); // 출력
                flag = 1; // swap 발생으로 인한 flag를 1으로 변경
            }
        }
    } while (flag != 0);

    return input; // 결과를 return
}

// 두 수를 swap하는 함수
function swap(num1, num2) {
    return [num2, num1];
}

const fs = require('fs');
const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');

// 입력 받은 행의 값을 숫자로 변환 후 배열로 저장
const scores = input[0].split(' ').map(Number);

// 함수 실행
getSwapAndSort(scores);




